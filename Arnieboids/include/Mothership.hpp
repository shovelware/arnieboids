#ifndef _MOTHERSHIP_H
#define _MOTHERSHIP_H

#include "Predator.hpp"
#include "SwarmBoid.hpp"
#include "Missile.hpp"

/*
 * \brief Ship that spawns other ships.
 * Wanders when no other Motherships nearby.
 * Flocks with other Motherships when they're near.
 * Evades player (and fires homing missiles) if he's too close.
 * Spawns a Predator ship at uniform intervals.
 */
class Mothership : public Ship {
public:
	/*
	 * \brief Constructs a mothership
	 * \param particleSystem Particle system to connect the ship's emitter to.
	 * \param fireCallback Invoked whenever the ship wishes to fire a Missile.
	 * \param spawnCallback Invoked whenever the ship wishes to spawn a Predator.
	 * \param position Initial position of the ship.
	 */
	Mothership(thor::ParticleSystem &particleSystem, std::function<void(Bullet*)> const &fireCallback, std::function<void(Ship*)> spawnCallback, sf::Vector2f position);
	~Mothership();

	/*
	 * \brief Calculates state and runs AI behaviour.
	 * Spawns a Predator of it's time to do so.
	 * Calls wander(), flock() or evade() depending on result of calculateState() and distance to player.
	 */
	void update() override;

	//! Takes damage if the ship is a Player ship.
	void onCollide(Ship* other) override;

	//! Sets the target for all motherships
	static void setTarget(Ship* target);
protected:
	void updateParticleEmitter() override;
private:
	thor::ParticleSystem &particleSystem_;	//needed to spawn ships
	
	//! Number of calls to update since a Predator was spawned
	unsigned int ticksSinceLastSpawn_;

	//! Amount of ticks that must go by before we will spawn a Predator
	const unsigned int ticksPerSpawn_;

	//! Method used to fire a bullet into the game world
	std::function<void(Bullet*)> fireBullet_;

	//! Method used to spawn a ship into the game world
	std::function<void(Ship*)> spawnShip_;

	//! Target for all motherships
	static Ship* target_;

	enum State {
		WANDER,
		EVADE
	};
	/*
	 * \brief Calculates the state of the Mothership: WADNER or EVADE, depending on the distance to the target.
	 * \returns EVADE if the target is closer than 300 pixels, WANDER otherwise.
	 */
	State calculateState(sf::Vector2f const &displacementFromTarget) const;

	/*
	 * \brief Calculates where to go to get away from target_
	 * \returns A vector that will lead the ship away from target_
	 */
	sf::Vector2f evade(sf::Vector2f const &displacementFromTarget) const;

	/*
	 * \brief Picks a random location ahead of the ship (within a specified angle and distance).
	 * Only generates a new location if close to, or far away from, exisitng location.
	 * \returns A vector that the ship should go toward to emulate wandering behaviour.
	 */
	sf::Vector2f wander();

	//! Holds the vector generated by wander()
	sf::Vector2f wanderWaypoint_;

	//! Tries to fire a missile toward target. Does nothing if max missiles already live.
	void fire();
	const unsigned int MAX_LIVE_MISSILES;	//!< The maximum number of missiles the ship can have live at a time.
	unsigned int liveMissiles_;	//!< The number of currently live missiles.
	void missileDestructed();	//!< Decrements liveMissiles_. Called by Missile::destructCallback_.

	//! A list of all other motherships.
	std::list<Mothership*> flock_;

	/*! \brief Keeps ships from piling on top of each other
	* \returns The desired position after separation.
	*/
	sf::Vector2f separation() const;

	/*! \brief Keeps the ship moving in the same direction as nearby flockmates.
	* Finds the averagelocation of nearby flockmates and manipulates
	* the steering force to move in that direction.
	* \returns The desired position after cohesion.
	*/
	sf::Vector2f cohesion() const;

	/*! \brief
	* \returns The desired heading after alignment.
	*/
	sf::Vector2f alignment() const;

	/*!
	 * \brief Runs separation(), cohesion() and alignment().
	 * Weights the results.
	 * \returns A vector of the weighted results summed together.
	 */
	sf::Vector2f flock() const;
};
#endif